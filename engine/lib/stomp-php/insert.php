<?php
    // include a library
    require_once("Stomp.php");
	require_once("Stomp/Message/Map.php");
    // make a connection
    $con = new Stomp("tcp://10.24.5.215:61613");
	 echo "New Stomp\n";
    // connect
    $con->connect("user", "admin");
	 echo "Connected\n";
	 
    // send a message to the queue
	$message = "<?xml version='1.0' encoding='UTF-8'?><elgg><action>ADD</action><status type=\"integer\">0</status><object type=\"array\"><array_item name=\"0\" type=\"object\"><id type=\"string\">5544</id><author type=\"string\">3721</author><author_name type=\"string\">Angelo Bianco</author_name><access_id type=\"string\">1</access_id><timestamp type=\"string\">1371461192</timestamp><name type=\"string\">Carrot2 e LINGO</name><content type=\"string\">Carrot2 &amp;egrave; un motore open-source che effettua il clustering dei documenti, siano essi in locale o presenti sul web. Tale motore consente, quindi, di organizzare una collezione di documenti secondo categorie tematiche(topic).Carrot2 si inserisce nel contesto della piattaforma KnoBoos creando facets automatiche e dinamiche a supporto delle funzionalit&amp;agrave; di ricerca dei documenti fornite dalla stessa piattaforma. Poter organizzare i risultati di una ricerca in topic consente di individuare in maniera pi&amp;ugrave; efficiente e veloce i documenti di interesse, migliorando l&amp;rsquo;efficacia delle funzionalit&amp;agrave; di information retreival. Il clustering engine di Carrot2, oltre ad essere presente in versione stand-alone, &amp;egrave; integrato in Apache Solr. In questo modo &amp;egrave; possible effettuare il clustering dei documenti direttamente all&amp;rsquo;interno di KnoBoos.L&amp;rsquo;algoritmo alla base del funzionamento di Carrot2 &amp;egrave; LINGO, il quale sfrutta i concetti di Vector Space Model &amp;nbsp;e Latent Semantic Indexing (LSI) per trovare i cluster ( i topic che saranno visualizzati all&amp;rsquo;utente) ed inserire i documenti nel cluster pi&amp;ugrave; appropriato.Il concetto di Vector Space Model consente di rappresentare i documenti come vettori multidimensionali. Ogni elemento del vettore rappresenta un termine legato al documento stesso e la forza di tale legame &amp;egrave; tipicamente indicata con un valore numerico(peso). In questo modo un documento pu&amp;ograve; essere visto come una serie di termini che lo caratterizzano, ognuno con una importanza pi&amp;ugrave; o meno significativa. In generale il processo di assegnazione dei pesi pu&amp;ograve; utilizzare diversi schemi e politiche e, nello specifico, &amp;nbsp;in LINGO viene utlizzato lo schema denominato tf-idf (term frequency - inverse document frequency). Utilizzano questo modello, una collezione di documenti pu&amp;ograve; essere rappresentata come una matrice t x d &amp;nbsp;detta matrice termini-documenti dove t &amp;egrave; il numero di termini utilizzati per rappresentare i documenti e &amp;nbsp;d &amp;egrave; il numero di documenti presenti nella collezione. Allo stesso modo una query sui documenti pu&amp;ograve; essere rappresentato con un vettore di termini le cui componenti non nulle sono esattamente i termini specificati nella query stessa. Calcolando la distanza tra il vettore della query ed i vettori dei documenti &amp;egrave; possibile restituire tutti i documenti che pi&amp;ugrave; si avvicinano alla richiesta dell&amp;rsquo;utente.Come detto in precedenza, LINGO utilizza il concetto di LSI per migliorare i risultati del clustering. L&amp;rsquo;obiettivo principale del Latent Semantic Indexing &amp;egrave; quello di estrapolare dalla matrice termini-documenti quelli che vengono definiti concetti astratti. Tali concetti astratti verrano utilizzati per costruire una approssimazione della matrice termini-documenti originale priva di termini ridondanti ( come per esempio i sinonimi) e mettere in risalto i legami semantici tra i vari documenti della collezione. Alla base del funzionamento LSI vi &amp;egrave; quella che viene definita Singular Value Decomposition (SVD) che decompone la matrice originale termini-documenti(definiamola matrice A) in tre matrici, in modo che :A = U&amp;Sigma;VLa matrice U riveste speciale importanza in LINGO, ed in particolare le sue prime rA colonne, dove &amp;nbsp;rA &amp;egrave; il rango dell matrice originale A. Esse infatti costituiscono una base ortogonale per lo spazio delle colonne di A e rappresentano i concetti astratti su cui si basa LSI. A questo punto &amp;egrave; possibile scegliere k colonne di U per costruire una rappresentazione di A, detta Ak. Tale matrice, di rango inferiore alla matrice originale, diminuisce il numero di dimensione sulle quali &amp;egrave; espresso ogni documento, eliminando cos&amp;igrave; il rumore e le informazioni estranee dalla matrice A.Di seguito sono presentati i passi dell&amp;rsquo;algoritmo:/** Phase 1: Preprocessing */for each document{&amp;nbsp; &amp;nbsp; do text filtering;&amp;nbsp; &amp;nbsp; identify the document's language;&amp;nbsp; &amp;nbsp; apply stemming;&amp;nbsp; &amp;nbsp; mark stop words;}/** Phase 2: Feature extraction */discover frequent terms and phrases;/** Phase 3: Cluster label induction */use LSI to discover abstract concepts;for each abstract concept{&amp;nbsp; &amp;nbsp; find best-matching phrase;}prune similar cluster labels;/** Phase 4: Cluster content discovery */for each cluster label{&amp;nbsp; &amp;nbsp; use VSM to determine the cluster contents;}/** Phase 5: Final cluster formation */calculate cluster scores;apply cluster merging;&amp;nbsp;Nel prossimo post descriver&amp;ograve; con maggiore precisione i passi dell'algoritmo.</content><tags type=\"array\"><array_item name=\"0\" type=\"string\">Carrot2</array_item><array_item name=\"1\" type=\"string\">Lingo</array_item><array_item name=\"2\" type=\"string\">KnoBoos</array_item><array_item name=\"3\" type=\"string\">Clustering</array_item></tags><link type=\"string\">/nexu/blog/view/3911/carrot2-e-lingo</link><content_type type=\"string\">blog</content_type></array_item></object></elgg>";
    $con->send("jms.queue.documentqueue", $message);
    echo "Sent message with body 'test'\n";
    // subscribe to the queue
    //$con->subscribe("/jms/queue/documentqueue");
    // receive a message from the queue
    //$msg = $con->readFrame();

    // do what you want with the message
    //if ( $msg != null) {
       // echo "Received message with body '$msg->body'\n";
        //mark the message as received in the queue
      //  $con->ack($msg);
    //} else {
      //  echo "Failed to receive a message\n";
    //}

    // disconnect
    $con->disconnect();
?>